# 翻译@View Controller Programming Guide for iOS（iOS视图控制器编程指南）

- 原文：[View Controller Programming Guide for iOS](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457-CH2-SW1)
- 作者：[Apple](https://developer.apple.com/library/content/navigation/)
- 更新：[Yannmm@Github.com](https://github.com/Yannmm/Auto-Layout-Guide-Chinese-Translation)

---

## View Controller Definition（视图控制器基础）


### Defining Your Subclass（创建子类）

app使用[UIViewController](https://developer.apple.com/documentation/uikit/uiviewcontroller)子类展示内容。其中大多数都是内容控制器，控制视图，组织数据；另一小部分是容器控制器，组织管理子控制器的视图。不论定义哪种控制器，其过程大致相同。

对于内容控制器，通常基于下列父类创建：

- 表格：[UITableViewController](https://developer.apple.com/documentation/uikit/uitableviewcontroller)；
- 集合：[UICollectionViewController](https://developer.apple.com/documentation/uikit/uicollectionviewcontroller)；
- 其它：[UIViewController](https://developer.apple.com/documentation/uikit/uiviewcontroller)。

至于容器控制器，父类的选择取决于具体需求：可以基于现有容器控制器修改，也可以从头创建。前者选择合适的父类即可，后者直接继承自[UIViewController](https://developer.apple.com/documentation/uikit/uiviewcontroller)。更多信息，详见[Implementing a Container View Controller](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/ImplementingaContainerViewController.html#//apple_ref/doc/uid/TP40007457-CH11-SW1)。

#### Defining Your UI（编写UI）

storyboard创作UI是最佳选择，与代码相比，好处在于所见即所得，适配简单，不必重新编译。

图4-1是一个storyboard：每个矩形代表一个视图控制器，箭头代表容器控制器与子控制器之间的关系，或两个控制器之间的界面转换。

**图4-1** 一个包含多个视图控制器的storyboard

![图4-1]()

每个新项目都附带一个storyboard，称为main storyboard，以项目模版为准，包含若干视图控制器。从素材库中拖拽新控制器到画布上，随后在身份面板制定它的class。

storyboard功能如下：

- 添加，布局，配置视图；
- 添加outlets和动作，详见[Handling User Interactions](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/DefiningYourSubclass.html#//apple_ref/doc/uid/TP40007457-CH7-SW11)；
- 定义关系和segue，详见[Using Segues](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/UsingSegues.html#//apple_ref/doc/uid/TP40007457-CH15-SW1)；
- 适配不同size class，详见[Building an Adaptive Interface](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/BuildinganAdaptiveInterface.html#//apple_ref/doc/uid/TP40007457-CH32-SW1)；
- 添加手势识别器，处理交互，详见`Event Handling Guide for iOS`。

如果你尚未掌握stroyboard，请事先阅读`Start Developing iOS Apps Today`。

#### Handling User Interactions（用户交互）

响应对象负责处理交互事件。控制器虽然是响应对象的一种，但它很少亲自处理，而是：

- **定义动作方法直接处理结果**，[动作方法（action methods）](https://developer.apple.com/library/content/documentation/General/Conceptual/Devpedia-CocoaApp/TargetAction.html#//apple_ref/doc/uid/TP40009071-CH3)会被下列情况触发：

	- 特定动作：控件和某些视图会针对特定交互触发动作方法；
	- 手势识别器：侦测到指定手势时，触发动作方法。控制器应该根据处理这些状态变化，响应手势的完成。

- **接收通知**，控制器更新自身状态；
- **扮演数据源或代理**，控制器通常是列表和集合视图的数据源；还可以是诸如[CLLocationManager](https://developer.apple.com/documentation/corelocation/cllocationmanager)对象的代理，接收位置更新。


响应的关键在于更新视图，而更新视图的前提是持有它。视图控制器通过定义[outlets](https://developer.apple.com/library/content/documentation/General/Conceptual/Devpedia-CocoaApp/Outlet.html#//apple_ref/doc/uid/TP40009071-CH4)引用视图。语法如代码4-1所示，与属性的声明很类似。通过定义两个outlet（用关键字[IBOutlet](https://developer.apple.com/documentation/appkit/constants/interface_builder_constants/iboutlet)表示），和一个动作方法（关键字[IBAction](https://developer.apple.com/documentation/appkit/constants/interface_builder_constants/ibaction)表示）。outlet指向storyboard中的按钮和文本框，动作方法响应按钮点击事件。

**代码4-1** 定义outlet和动作方法

```
// OBJECTIVE-C
@interface MyViewController : UIViewController
@property (weak, nonatomic) IBOutlet UIButton *myButton;
@property (weak, nonatomic) IBOutlet UITextField *myTextField;
 
- (IBAction)myButtonAction:(id)sender;
 
@end

// SWIFT
class MyViewController: UIViewController {
    @IBOutlet weak var myButton : UIButton!
    @IBOutlet weak var myTextField : UITextField!
    
    @IBAction func myButtonAction(sender: id)
}

```

记得在storybaord中连接视图与outlet或动作方法。UIKit载入视图时会自动建立这些连接。更多关于使用Interface Builder建立连接的信息，详见`Interface Builder Connections Help`。更多关于事件处理的信息，详见`Event Handling Guide for iOS`。

记号

#### 显示视图（Displaying Your Views at Runtime）

使用storyboard，加载和显示控制器的过程十分简单。系统按需自动从storyboard中读取视图。作为加载过程的一部分，系统将完成下述任务：

1. 使用storyboard中的信息初始化视图；
2. 链接outlet和动作方法；
3. 为控制器属性[view](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621460-view)赋值；
4. 调用控制器方法[awakeFromNib](https://developer.apple.com/documentation/objectivec/nsobject/1402907-awakefromnib)；
	
	这个方法调用时，控制器的显示特征仍为空，视图位置可能不是最终位置。
	
5. 调用控制器方法[viewDidLoad](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621495-viewdidload)。

	 使用这个方法添加或移除视图，修改约束，加载数据。
	 
显示控制器视图之前，仍有机会在显示前后调整视图。系统将依次调用下述方法：

1. 控制器方法[viewWillAppear:](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621510-viewwillappear)，表示视图即将显示；
2. 更新视图布局；
3. 显示在屏幕上；
4. 控制器方法[viewDidAppear:](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621423-viewdidappear)，表示视图已经显示在屏幕上。

无论是添加，移除，还是修改视图的位置或尺寸，记得添加或移除相应的约束。修改约束，系统会将布局标记为需要重新计算。下次更新循环时，布局引擎会使用新的约束计算视图的尺寸和位置，调整视图结构。

更多信息，详见[UIViewController Class Reference](https://developer.apple.com/documentation/uikit/uiviewcontroller)。

#### 管理视图布局（Managing View Layout）

视图尺寸和位置变化时，系统将更新布局信息。如果使用Auto Layout时，系统使用布局引擎，根据约束更新布局。此外，系统还会通知其它对象，如呈现管理器，以便其作出相应改变。

布局时，系统会分阶段通知，便于我们做出改变。在这些时候修改布局约束，或对布局做最后调整。整个过程如下：

1. 更新控制器，视图的显示属性，如需，详见[When Do Trait and Size Changes Happen?](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/TheAdaptiveModel.html#//apple_ref/doc/uid/TP40007457-CH19-SW6)
2. 调用控制器方法[viewWillLayoutSubviews](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621437-viewwilllayoutsubviews)。
3. 调用[UIPresentationController](https://developer.apple.com/documentation/uikit/uipresentationcontroller)方法[containerViewWillLayoutSubviews](https://developer.apple.com/documentation/uikit/uipresentationcontroller/1618341-containerviewwilllayoutsubviews)。
4. 调用控制器根视图方法[layoutSubviews](https://developer.apple.com/documentation/uikit/uiview/1622482-layoutsubviews)。

	这个方法的默认实现利用现有约束计算布局信息。这个方法会遍历整个视图结构，调用每个子视图的`layoutSubviews`。
	
5. 将计算好的布局信息赋给视图。
6. 调用控制器方法[viewDidLayoutSubviews](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621398-viewdidlayoutsubviews)。
7. 调用当前[UIPresentationController](https://developer.apple.com/documentation/uikit/uipresentationcontroller)对象方法[containerViewDidLayoutSubviews](https://developer.apple.com/documentation/uikit/uipresentationcontroller/1618331-containerviewdidlayoutsubviews)。

控制器可以使用`viewWillLayoutSubviews`以及`viewDidLayoutSubviews`来实现对于布局的更新和修改。布局钱，可以添加或移除视图，更新视图的尺寸和位置，更新约束，甚至更新其它视图属性。布局后，可以重新载入数据，更新其它视图的内容，或对视图位置和尺寸做最后调整。

以下是对布局管理的一些提示：

- **使用自动布局**。使用自动布局创建的约束十分灵活，易于修改，可以使用不同屏幕尺寸。
- **利用上下布局参考**。根据这些参考布局内容，可以保证你的内容总是可以完全显示。顶部布局参考是对状态栏河导航栏高度的反应。类似的，底部参考是对标签栏或工具栏高度的反应。
- **记得在添加或移除视图后更新约束**。 动态添加和移除视图时，记得更新相应的约束。
- **做动画时，要临时移除约束**。系统使用Core Animation实现动画，记得在动画期间移除约束，动画结束后将约束加回去。如果动画使得视图的位置或尺寸变化，记得更新约束。

更多关于呈现管理器的信息，详见[The Presentation and Transition Process](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/PresentingaViewController.html#//apple_ref/doc/uid/TP40007457-CH14-SW7)。


#### 内存管理（Managing Memory Efficiently）

尽管大部分内存管理工作都不需要我们操心，表4-1列举了[UIViewController](https://developer.apple.com/documentation/uikit/uiviewcontroller)的一些方法，其很有可能牵扯到分配和取消内存。大部分销毁时，都需要移除强引用。要移除强引用，将属性或变量置为`nil`即可。

**表4-1** 分配和销毁内存的方法

任务 | 方法 | 说明
------------- | ------------- | -------------
分配控制器所需的关键数据 | 初始化方法 | 自定义[初始化](https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/Initialization.html#//apple_ref/doc/uid/TP40008195-CH21)方法（不管是名为`init`还是别的）必须负责将控制器对象提升到已知状态。使用这些方法分配数据结构，只要是控制器操作所需要的。
分配视图展示所需的数据 | [viewDidLoad](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621495-viewdidload) | 使用`viewDidLoad`方法子载入要显示的数据。这个方法调用时，视图对象已经存在，状态已知。
响应低内存通知 | [didReceiveMemoryWarning](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621409-didreceivememorywarning) | 使用这个方法销毁非关键对象，尽量释放内存。
使用控制器所持有的关键数据结构 | [dealloc](https://developer.apple.com/documentation/objectivec/nsobject/1571947-dealloc) | 充血这个方法，进行最后的扫尾工作。系统自动释放所有属性和变量，所以无需在这里重复。
