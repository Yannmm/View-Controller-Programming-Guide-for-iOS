# 翻译@View Controller Programming Guide for iOS（iOS视图控制器编程指南）

- 原文：[View Controller Programming Guide for iOS](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457-CH2-SW1)
- 作者：[Apple](https://developer.apple.com/library/content/navigation/)
- 更新：[Yannmm@Github.com](https://github.com/Yannmm/Auto-Layout-Guide-Chinese-Translation)

---


## View Controller Definition（视图控制器基础）

### Implementing a Container View Controller（实现容器控制器）

容器控制器组合显示多个视图控制器的内容，定义页面结构，基于现有内容创造页面。典型例子包括`UINavigationController`，`UITabBarController`及`UISplitViewController`，便于我们组织页面。

#### Designing a Custom Container View Controller（设计自定义容器控制器）

容器控制器与内容控制器一样，管理根视图和若干子视图。区别在于前者将子控制器内容放入自己的根视图，设置尺寸和位置，但内容仍由原控制器管理。

设计容器控制器时，必须明确与子控制器之间的关系，是决定子控制器内容显示和管理的关键。尝试回答下列问题：

- 容器控制器和子控制器分别扮演什么角色？
- 同时显示几个子控制器？
- 子控制器之间的关系？
- 如何添加和移除子控制器？
- 子控制器内容的尺寸和位置能否变化？何时变化？
- 有没有额外的装饰性，功能性视图？
- 容器控制器与子控制器之间是否交换信息？如知会某些事件的发生，而且这些事件是[UIViewController](https://developer.apple.com/documentation/uikit/uiviewcontroller)没有定义的？
- 容器控制器是否支持配置外观？如果可以，如何配置？

关系一旦明确，按部就班的实现即可。UIKit要求容器控制器与子控制器之间建立父子关系，以保证系统消息的正确传递。剩余的工作集中在视图管理上：定义内容视图尺寸和位置，酌情添加功能性视图，以实际需求为准。

##### Example: Navigation Controller（案例：导航控制器）

[UINavigationController](https://developer.apple.com/documentation/uikit/uinavigationcontroller)是层级导航的典范，一次显示一个子控制器，层层递进。导航栏显示当前位置，返回按钮返回上一级。需要展开详细内容时，也可以使用列表和按钮。

整个界面转换过程由导航控制器和子控制器联合控制。例如，用户点击按钮或列表时，展示下一级页面：前者负责显示，后者负责配置。此外，导航控制器还管理导航栏，其包含返回按钮，标题等信息。

图5-1是导航控制器界面构成的示意图。大部分区域被最上层子控制器内容占据，剩下一小部分是导航蓝的位置。

**图5-1** 导航控制器界面构成

![图5-1]()

不论在何种显示环境下（紧凑或正常），一次只显示一个子控制器。


##### Example: Split View Controller（例子：分屏控制器）

[Example: Split View Controller](https://developer.apple.com/documentation/uikit/uisplitviewcontroller)以主从模式（master-detail）显示两个控制器，后者以前者为准。子控制器是否可见取决于配置和显示环境：正常宽度下，可同时显示，也可以隐藏主控制器；紧凑宽度下，一次只显示一个控制器。

图5-2是正常宽度下分屏控制器的页面样式：根视图作为容器，两个子控制器并排显示。子控制器视图的尺寸，主控制器是否隐藏都可以调整。

**图5-2** 分屏控制器页面

![图5-2]()

#### Configuring a Container in Interface Builder（通过Interface Builder配置容器控制器）

将容器视图拖入storyboard，如图5-3所示。容器视图代表子控制器内容，起占位作用。调整其尺寸和位置，就是调整子控制器视图的尺寸和位置。

**图5-3** 添加容器视图

![图5-3]()

UIKit从storyboard载入容器控制器时，会自动载入相应的子控制器，父子关系确定。

纯代码编写时，需要将子控制器加入容器控制器，详见[Adding a Child View Controller to Your Content](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/ImplementingaContainerViewController.html#//apple_ref/doc/uid/TP40007457-CH11-SW13)。

#### Implementing a Custom Container View Controller（实现自定义容器控制器）

实现容器控制器的关键在于明确父子关系。它是我们管理子控制器的原则，进而确定子控制器视图的尺寸和位置。不管是使用Interface Builder或纯代码实现，是必须的。


##### Adding a Child View Controller to Your Content（添加子控制器）

以代码形式添加子控制器，建立父子关系的方式如下：

1. 调用容器控制器方法[addChildViewController:](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621394-addchildviewcontroller)；

	告诉UIKit子控制器视图正式归容器控制器管理。
	
2. 将子控制器根视图加入容器控制器的视图结构；

	同时设置其位置和尺寸。
	
3. 添加约束，固定位置和尺寸；
4. 调用子视图方法[didMoveToParentViewController:](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621405-didmovetoparentviewcontroller)。

代码5-1是上述过程的具体实现。父子关系一旦确立，应该在加入视图结构前确定frame，保证正确显示。最后，调用子控制器方法`didMoveToParentViewController:`，通知其已经加入容器控制器。

**代码5-1** 添加子控制器

```
- (void) displayContentController: (UIViewController*) content {
   [self addChildViewController:content];
   content.view.frame = [self frameForContentController];
   [self.view addSubview:self.currentClientView];
   [content didMoveToParentViewController:self];
}
```

注意，子控制器视图一旦加入视图结构，需要立即调用方法`didMoveToParentViewController:`。而方法`willMoveToParentViewController:`由方法`addChildViewController:`自动触发，无须手动调用。

如果使用Auto Layout，则在加入视图结构后立即添加约束，定义尺寸和位置，但不要尝试修改内容或视图结构。

记号

#### Removing a Child View Controller（移除子控制器）

要移除子控制器，解除父子关系即可，方法如下：

1. 调用子控制器方法[willMoveToParentViewController:](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621381-willmovetoparentviewcontroller)，参数为nil；
2. 移除子视图约束；
3. 将子视图移除视图结构；
4. 低啊用子控制器方法[removeFromParentViewController](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621425-removefromparentviewcontroller)，正式解除父子关系。

父子关系一旦接触，就斩断了二者的联系。所以，只在不需要子控制器后再移除。例如，导航控制器即使有心的子控制器加入，也不会移除旧的，而是在出栈的时候移除。

代码5-2是一个移除示范。调用子控制器方法`willMoveToParentViewController:`，参数为nil，便于子控制器做出准备。方法`removeFromParentViewController `会同时调用子控制器方法[didMoveToParentViewController:](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621405-didmovetoparentviewcontroller)，参数也为nil。将父控制器设置为nil，标志在关系彻底解除。

**代码5-2** 移除子控制

```
- (void) hideContentController: (UIViewController*) content {
   [content willMoveToParentViewController:nil];
   [content.view removeFromSuperview];
   [content removeFromParentViewController];
}
```

#### Transitioning Between Child View Controllers（子控制器之间的切换）

一个控制器切换显示至另一个时，需要添加过渡动画。起初，两个控制器都是内容，但要消失的必须知道自己应该消失。过渡期间，将新内容过渡至位置，移除旧内容。完成后，完全移除旧内容。

代码5-3显示了一个过渡例子。例子中，新控制器过渡至位置，旧内容移动至屏幕外。动画完成后，旧内容的父子关系被解除。方法[transitionFromViewController:toViewController:duration:options:animations:completion:](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621363-transition)自动更新容器视图的视图结构，所以无须自己添加和删除视图。

**代码5-3** 两个子控制器之间的过渡

```
- (void)cycleFromViewController: (UIViewController*) oldVC
               toViewController: (UIViewController*) newVC {
   // Prepare the two view controllers for the change.
   [oldVC willMoveToParentViewController:nil];
   [self addChildViewController:newVC];
 
   // Get the start frame of the new view controller and the end frame
   // for the old view controller. Both rectangles are offscreen.
   newVC.view.frame = [self newViewStartFrame];
   CGRect endFrame = [self oldViewEndFrame];
 
   // Queue up the transition animation.
   [self transitionFromViewController: oldVC toViewController: newVC
        duration: 0.25 options:0
        animations:^{
            // Animate the views to their final positions.
            newVC.view.frame = oldVC.view.frame;
            oldVC.view.frame = endFrame;
        }
        completion:^(BOOL finished) {
           // Remove the old view controller and send the final
           // notification to the new view controller.
           [oldVC removeFromParentViewController];
           [newVC didMoveToParentViewController:self];
        }];
}

```

#### Managing Appearance Updates for Children（管理控制器显示更新）

加入容器控制器后，容器自动将显示相关信息转发给子控制器。这是默认的最佳行为，确保所有事件正确发放。然而，有时默认行为的发送顺序可能不是我们想要的。例如，如果多个子控制器同时改变状态，我们想要控制器先后顺序。

要控制器显示更新消息的发送，重写容器控制器方法[shouldAutomaticallyForwardAppearanceMethods](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621389-shouldautomaticallyforwardappear)，如代码5-4所示。返回NO告诉系统容器控制器要自行控制器消息发送。

**代码5-4** 关闭显示更新自动转发

```
- (BOOL) shouldAutomaticallyForwardAppearanceMethods {
    return NO;
}
```

显示状态发生变化时，调用子控制器方法[beginAppearanceTransition:animated:](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621387-beginappearancetransition)或[endAppearanceTransition](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621503-endappearancetransition)。例如，控制器有一个属性`child`，指向自己的子控制器，可以像代码5-5一样转发消息。

**代码5-5** 转发显示消息

```
-(void) viewWillAppear:(BOOL)animated {
    [self.child beginAppearanceTransition: YES animated: animated];
}
 
-(void) viewDidAppear:(BOOL)animated {
    [self.child endAppearanceTransition];
}
 
-(void) viewWillDisappear:(BOOL)animated {
    [self.child beginAppearanceTransition: NO animated: animated];
}
 
-(void) viewDidDisappear:(BOOL)animated {
    [self.child endAppearanceTransition];
}

```

### Suggestions for Building a Container View Controller（容器控制器建议）

设计，开发以及测试控制器需要时间。虽然单个功能都很直白，控制器综合在一起却可以是一个复杂工程。下面是一些提示：

- **只访问子控制器的根视图**。即子控制器属性[view](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621460-view)所返回的视图。其它视图一律不动。

- **子控制器不应该知晓容器控制器**。子控制器因该专注于内容。如果容器受子控制器影响，则应该使用[delegation](https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/Delegation.html#//apple_ref/doc/uid/TP40008195-CH14)模式。
- **使用常规视图设计容器控制器**。使用常规视图（而非来自子控制器的视图）使得我们有机会在一个简单环境测试布局约束和动画专场。常规视图负责预期，则转为使用自定义子控制器。

### Delegating Control to a Child View Controller（将控制权交给子控制器）

容器控制器可以将某些控制权转交给子控制器。通过以下方式：

- **状态样式**。重写方法`childViewControllerForStatusBarStyle`以及`childViewControllerForStatusBarHidden`。
- **尺寸**。使用子控制器属性[preferredContentSize](https://developer.apple.com/documentation/uikit/uicontentcontainer/1621481-preferredcontentsize)布局即可。


## 忽略章节 Supporting Accessibility 和 Preserving and Restoring State