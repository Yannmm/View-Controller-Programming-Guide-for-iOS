# 翻译@View Controller Programming Guide for iOS（iOS视图控制器编程指南）

- 原文：[View Controller Programming Guide for iOS](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457-CH2-SW1)
- 作者：[Apple](https://developer.apple.com/library/content/navigation/)
- 更新：[Yannmm@Github.com](https://github.com/Yannmm/Auto-Layout-Guide-Chinese-Translation)

---

## Presentations and Transitions（显示和转场）

### Presenting a View Controller（直接显示）

在屏幕上显示视图控制器有两种方式：放入容器或直接显示。对于App页面结构来说，前者是基础；后者起辅助作用。直接显示时，控制器位于最上层。其典型的应用场景是制造焦点界面（Modal Interface），不过也可以另作他用 。（译者：不理解Modal含义的同学，可以参考wikipedia上关于[Modal Window](https://en.wikipedia.org/wiki/Modal_window)的定义）

[UIViewController](https://developer.apple.com/documentation/uikit/uiviewcontroller)及其子类天生支持直接显示。暂不考虑UIKit的消息转发机制，任意控制器都可以直接显示其他控制器。此时，它们之间是显示（presenting）与被显示（presented）的关系，是整个控制器体系的一部分。一旦形成，这种关系将一直保持，直至取消（dismiss）。

#### The Presentation and Transition Process（显示和转场流程）

新控制器伴随着动画出现在屏幕上的过程，称为转场（效果）（Transition）；在屏幕上的显示方式，称为呈现形式（Presentation）。UIKit在提供若干预设选项的同时，也允许我们自定义。使用前者，系统会替我们搞定一切；使用后者，也无需花费太多精力，且可以复用。

直接显示可以通过Storyboard Segue或代码发起。使用Storyboard设计页面结构时，前者简单易用。而对于动态界面，亦或是没有控件可供触发Segue时，则需使用[UIViewController](https://developer.apple.com/documentation/uikit/uiviewcontroller)相关方法。

##### Presentation Styles（呈现形式）

呈现形式决定显示效果。根据用途，UIKit定义了许多不同的呈现形式，当然也可以自定义。选择与需求相匹配的形式，为控制器属性[modalPresentationStyle](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621355-modalpresentationstyle)赋值。

###### Full-Screen Presentation Styles（全屏）

顾名思义，全屏呈现时控制器完整覆盖屏幕，无法与下层视图交互。正常宽度下（horizontally regular），只有`UIModalPresentationFullScreen`完整覆盖屏幕。其余形式使用遮罩覆盖下层内容。紧凑宽度下（horizontally compact），其余形式的实际效果与`UIModalPresentationFullScreen`保持一致。

图8-1演示了[UIModalPresentationFullScreen](https://developer.apple.com/documentation/uikit/uimodalpresentationstyle/uimodalpresentationfullscreen)，[UIModalPresentationPageSheet](https://developer.apple.com/documentation/uikit/uimodalpresentationstyle/uimodalpresentationpagesheet)和[UIModalPresentationFormSheet](https://developer.apple.com/documentation/uikit/uimodalpresentationstyle/1621491-formsheet)在正常宽度下的效果：绿色控制器直接显示蓝色控制器。注意，屏幕的其余部分被遮罩覆盖。

**图8-1** 全屏呈现

![图8-1]()

>注意
>
>使用`UIModalPresentationFullScreen`时，下层视图将在转场结束后移除。如需保留，则应使用[UIModalPresentationOverFullScreen](https://developer.apple.com/documentation/uikit/uimodalpresentationstyle/1621506-overfullscreen)。这对于包含透明区域的控制器来说很实用。

全屏意味着呈现方（presenting，相对于presented，即被呈现方）必须完整覆盖屏幕。否则，系统将从控制器体系中寻找第一个符合要求的控制器。如果找不到，则使用窗口（window）根控制器。

###### The Popover Style（弹窗）

[UIModalPresentationPopover](https://developer.apple.com/documentation/uikit/uimodalpresentationstyle/uimodalpresentationpopover)以弹窗的形式显示控制器，一般用来展示与当前焦点有关的信息和选项。正常宽度下，弹窗覆盖部分屏幕，如图8-2所示。点击弹窗以外区域，弹窗自动收起；紧凑宽度下，效果与[UIModalPresentationOverFullScreen](https://developer.apple.com/documentation/uikit/uimodalpresentationstyle/1621506-overfullscreen)一致。

**图8-2** 弹窗呈现

![图8-2]()

紧凑宽度下弹窗会切换为全屏，必须适配这种情况。为了使用户能够取消（dismiss），可以额外添加按钮，使用容器控制器，或其他呈现形式。

更多关于弹窗的实现细节，详见[Presenting a View Controller in a Popover](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/PresentingaViewController.html#//apple_ref/doc/uid/TP40007457-CH14-SW13)。

记号

###### The Current Context Styles（当前环境）  xxx翻译不通

[UIModalPresentationCurrentContext](https://developer.apple.com/documentation/uikit/uimodalpresentationstyle/1621493-currentcontext)覆盖当前界面上特定控制器的内容。使用这一样式时，需要将被覆盖控制器的属性[definesPresentationContext](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621456-definespresentationcontext)设置为YES。如图8-3所示，分屏控制器（split view controller）的其中一个子控制器被覆盖。

**图8-3** 当前环境

>注意
>
>使用`UIModalPresentationFullScreen`呈现时，UIKit在转场动画结束后移除下层内容。要保留下层内容，则可以使用[UIModalPresentationOverCurrentContext](https://developer.apple.com/documentation/uikit/uimodalpresentationstyle/uimodalpresentationovercurrentcontext)。如果上层内容包含透明区域，可以显示下层内容时，可以使用这个选项。

除了呈现上下文之外，转场动画效果也可以修改。通常，UIKit根据被呈现控制器属性[modalTransitionStyle](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621388-modaltransitionstyle)。如果呈现情景控制器属性[providesPresentationContextTransitionStyle](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621356-providespresentationcontexttrans)为YES，则使用其属性`modalTransitionStyle`中的值。

显示环境变化为紧凑宽度时，呈现形式则自动切换为[UIModalPresentationFullScreen](https://developer.apple.com/documentation/uikit/uimodalpresentationstyle/uimodalpresentationfullscreen)。为了适应这种变化，需要在自适应呈现代理处作出具体改变。

###### Custom Presentation Styles（自定义） 

[UIModalPresentationCustom](https://developer.apple.com/documentation/uikit/uimodalpresentationstyle/uimodalpresentationcustom)允许我们使用自定义样式呈现控制器，涉及到创建[UIPresentationController](https://developer.apple.com/documentation/uikit/uipresentationcontroller)子类，添加动画，以及设置被呈现控制器内容的最终位置。此外，还需要处理被呈现控制器在显示环境改变时进行适应。

更多关于如何进行自定义呈现的内容，详见章节[Creating Custom Presentations](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/DefiningCustomPresentations.html#//apple_ref/doc/uid/TP40007457-CH25-SW1)。


##### Transition Styles（转场效果） 

转场效果就是被呈现控制器内容显示在屏幕上时所伴随的动画。UIKit定义了一组预设动画，通过设置给被呈现控制器属性[modalTransitionStyle](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621388-modaltransitionstyle)，即可使用。呈现时，系统会自动实现相应动画。图8-4展示了标准的上滑效果（[UIModalTransitionStyleCoverVertical](https://developer.apple.com/documentation/uikit/uimodaltransitionstyle/1621455-coververtical)）。控制器B从屏幕下方，向上升起，直至覆盖当前控制器A。移除控制器B时，效果正好相反：B向下滑动，完全露出A。

**图8-4** 转场效果

![图8-4]()

自定义转场需要通过动画对象和转场代理共同实现。动画对象负责负责创建动画；转场对象提供负责在合适的时机操作动画对象。更多关于实现自定义转场的信息，详见[Customizing the Transition Animations](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/CustomizingtheTransitionAnimations.html#//apple_ref/doc/uid/TP40007457-CH16-SW1)。

##### Presenting Versus Showing a View Controller（Presenting vs Showing）

一个控制器显示另一个，有两种方法：

- 方法[showViewController:sender:](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621377-show)以及[showDetailViewController:sender:](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621432-showdetailviewcontroller)最为灵活，适应性强。这些方法允许呈现控制器自省处理呈现。例如，容器控制器通常会选择将目标控制器作为自控制器纳入视图结构，而非焦点呈现。默认，焦点呈现。
- [presentViewController:animated:completion:](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621380-presentviewcontroller)总是焦点呈现。这个方法的调用方有可能不是最中负责呈现的，但总是焦点呈现。这个方法会自动适应紧凑宽度。


方法`showViewController:sender:`以及`showDetailViewController:sender:`是进行呈现的最佳选择。其好处在于无需了解控制器结构以及调用方在视图结构中的位置。此外，还有利于控制器复用。

#### Presenting a View Controller（呈现控制器）

有三种方式发起呈现：

- segue。只需在IB中设置相应信息即可，其会自动触发。更多关于配置segue的信息，详见[Using Segues](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/UsingSegues.html#//apple_ref/doc/uid/TP40007457-CH15-SW1)；
- 方法[showViewController:sender:](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621377-show)以及[showDetailViewController:sender:](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621432-showdetailviewcontroller)。自定义控制器时，可以进一步修改这些方法的实现；
- 方法[presentViewController:animated:completion:](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621380-presentviewcontroller)。直接焦点呈现。

关于移除呈现中的控制器的信息，详见[Dismissing a Presented View Controller](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/PresentingaViewController.html#//apple_ref/doc/uid/TP40007457-CH14-SW10)。


#### Showing View Controllers（展示）

- 方法[showViewController:sender:](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621377-show)以及[showDetailViewController:sender:](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621432-showdetailviewcontroller)显示控制器时，整个过程简单明了：

	1. [创建](https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/ObjectCreation.html#//apple_ref/doc/uid/TP40008195-CH39)要呈现的控制器，填充所需数据；
	2. 设置控制器属性[modalPresentationStyle](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621355-modalpresentationstyle)，选择合适的呈现效果。注意，这个样式可能不是最后使用的样式；
	3. 设置控制器属性[modalTransitionStyle](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621388-modaltransitionstyle)，选择最合适的过场效果。注意，这可能并非最终效果。
	4. 使用方法[showViewController:sender:](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621377-show)或[showDetailViewController:sender:](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621432-showdetailviewcontroller)，展示控制器。


实际上，UIKit会将上述方法的调用转发给合适的控制器，再由其决定如何处理呈现，并有机会修改呈现和动画效果。例如，导航控制器会将目标控制器推入栈中。

关于展示和呈现控制器的区别，详见[Presenting Versus Showing a View Controller](https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/PresentingaViewController.html#//apple_ref/doc/uid/TP40007457-CH14-SW4)。

#### Presenting View Controllers Modally（焦点呈现）

直接呈现控制器时，需要向UIKit指明其呈现和过场效果。

1. [创建](https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/ObjectCreation.html#//apple_ref/doc/uid/TP40008195-CH39)要呈现的控制器，填充所需数据；
2. 设置控制器属性[modalPresentationStyle](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621355-modalpresentationstyle)，选择合适的呈现效果；
3. 设置控制器属性[modalTransitionStyle](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621388-modaltransitionstyle)，选择最合适的过场效果；
4. 调用当前控制器方法[presentViewController:animated:completion:](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621380-presentviewcontroller)。

方法`presentViewController:animated:completion:`的接收者可能不是最终负责呈现的控制器。呈现效果决定被呈现控制器的展示效果，以及对呈现控制器的要求。例如，全屏呈现效果必须由一个全屏控制器发起。如果当前控制器不满足条件，UIKit将沿着控制器结构寻找，直到找到合适的。焦点呈现完成之际，相关控制器的属性[presentingViewController](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621430-presentingviewcontroller)和[presentedViewController](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621407-presentedviewcontroller)得到更新。

代码8-1示范了如何使用呈现控制器。每当添加新菜谱时，App通过呈现一个导航控制器，要求用户填写菜谱基本信息。之所以使用导航控制器，是为了摆放取消和完成按钮。此外，导航控制器为界面的扩展性留下了空间，如果添加新页面，只需要加入导航控制器即可。

**代码8-1** 呈现控制器

```
- (void)add:(id)sender {
   // Create the root view controller for the navigation controller
   // The new view controller configures a Cancel and Done button for the
   // navigation bar.
   RecipeAddViewController *addController = [[RecipeAddViewController alloc] init];
 
   addController.modalPresentationStyle = UIModalPresentationFullScreen;
   addController.transitionStyle = UIModalTransitionStyleCoverVertical;
   [self presentViewController:addController animated:YES completion: nil];
}

```

#### Presenting a View Controller in a Popover（弹窗呈现）

使用弹窗，必须先配置。除了将呈现形式设置为[UIModalPresentationPopover](https://developer.apple.com/documentation/uikit/uimodalpresentationstyle/1621382-popover)，还需要配置如下属性：

- 设置属性[preferredContentSize](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621476-preferredcontentsize)，表示大小；
- 设置[UIPopoverPresentationController](https://developer.apple.com/documentation/uikit/uipopoverpresentationcontroller)的弹窗锚点，通过属性[popoverPresentationController](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621428-popoverpresentationcontroller)进行配置。只需通过下面方式之一设置：

	- 通过属性[barButtonItem](https://developer.apple.com/documentation/uikit/uipopoverpresentationcontroller/1622314-barbuttonitem)，根据bar button item固定；
	- 通过属性[sourceView](https://developer.apple.com/documentation/uikit/uipopoverpresentationcontroller/1622313-sourceview)和[sourceRect](https://developer.apple.com/documentation/uikit/uipopoverpresentationcontroller/1622324-sourcerect)明确设置。

还可以通过[UIPopoverPresentationController](https://developer.apple.com/documentation/uikit/uipopoverpresentationcontroller)对象进行进一步配置。弹窗呈现控制器还支持代理，以便处理呈现过程中发生的变化。例如，响应弹窗出现，消失，位置。更多关于这个对象的信息，详见[UIPopoverPresentationController Class Reference](https://developer.apple.com/documentation/uikit/uipopoverpresentationcontroller)。

#### Dismissing a Presented View Controller（取消呈现）

要取消呈现，调用呈现方的方法[dismissViewControllerAnimated:completion:](https://developer.apple.com/documentation/uikit/uiviewcontroller/1621505-dismissviewcontrolleranimated)。也可以针对被呈现方发送这个消息，UIKit自动将此消息转发给呈现方。

取消呈现之前，注意保存需要重要信息。取消后，控制器会从控制器结构中移除，其视图也会从界面上移除。如果没有强引用控制器，则其内存会被释放。

如果被呈现控制器必须回传数据，则建议使用[delegation](https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/Delegation.html#//apple_ref/doc/uid/TP40008195-CH14)机制实现。代理有利于控制器的复用。代理模式下，被呈现控制器弱引用呈现控制器，后者实现[protocol](https://developer.apple.com/library/content/documentation/General/Conceptual/DevPedia-CocoaCore/Protocol.html#//apple_ref/doc/uid/TP40008195-CH45)中的API。需要回传数据时，被呈现控制器调用代理方法。一般情况下，呈现方扮演被呈现方的代理。

#### Presenting a View Controller Defined in a Different Storyboard（呈现其他SB中的控制器）

控制器之间可以使用segue，但不能跨SB。此时，必须在呈现特定控制器之间创建它，如代码8-2所示。在例子中，新创建的控制器被焦点呈现，但也可以将其放入导航控制器或用其他方式展示。

**代码 8-2** 从SB中创建控制器

```
UIStoryboard* sb = [UIStoryboard storyboardWithName:@"SecondStoryboard" bundle:nil];
MyViewController* myVC = [sb instantiateViewControllerWithIdentifier:@"MyViewController"];
 
// Configure the view controller.
 
// Display the view controller
[self presentViewController:myVC animated:YES completion:nil];
```

一个App可以包含任意数量的SB。下述情况描述了一些常见的多SB场景：

- 项目团队人数众多，不同的用户界面由不同的团队负责。因此，多个SB有利于减少冲突。
- 使用的库预先定义了一组控制器类型；这组类型专门使用一个SB。
- 需要在外接显示器中展示内容。此时，可能需要将显示内容区分，放入另一个SB中去做。当然，此时，也可以使用自定义segue。

